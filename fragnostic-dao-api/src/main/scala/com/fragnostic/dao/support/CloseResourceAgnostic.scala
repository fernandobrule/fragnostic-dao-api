package com.fragnostic.dao.support

import java.sql._

import org.slf4j.{ Logger, LoggerFactory }

/**
 * Created by Fernando Brule on 30-06-2015 22:23:00.
 * Generated by Tesseract.
 */
trait CloseResourceAgnostic {

  private[this] val logger: Logger = LoggerFactory.getLogger(getClass.getName)

  def closeWithoutCommit(connection: Connection): Unit =
    try {
      connection.close()
      if (logger.isInfoEnabled) logger.info("closeWithoutCommit | Connection closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
    }

  def closeWithoutCommitAndReturnNone(connection: Connection): Option[Nothing] = {
    closeWithoutCommit(connection)
    logger.error(s"closeAndReturnNone() - None")
    None
  }

  def closeWithoutCommitAndReturnError(connection: Connection, error: String): String = {
    closeWithoutCommit(connection)
    logger.error(s"closeAndReturnError() - $error")
    error
  }

  def closeWithCommit(connection: Connection): Unit =
    try {
      connection.commit()
      connection.close()
      if (logger.isInfoEnabled) logger.info("closeWithCommit | Connection commited and closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
    }

  def closeWithCommitAndReturnSomething[T](connection: Connection, t: T): T = {
    closeWithCommit(connection)
    logger.error(s"closeWithCommitAndReturnSomething() - $t")
    t
  }

  def closeWithRollBack(connection: Connection): Unit =
    try {
      connection.rollback()
      connection.close()
      if (logger.isInfoEnabled) logger.info("closeWithRollBack | Connection rolled back and closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
    }

  def close(statement: Statement): Unit =
    try {
      statement.close()
      if (logger.isInfoEnabled) logger.info("close | Statement closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
    }

  def close(resultSet: ResultSet, prepStat: PreparedStatement): Unit = {
    close(resultSet)
    close(prepStat)
  }

  def close(prepStat: PreparedStatement): Unit =
    try {
      prepStat.close()
      if (logger.isInfoEnabled) logger.info("close | PreparedStatement closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
    }

  def close(resultSet: ResultSet): Unit =
    try {
      resultSet.close()
      if (logger.isInfoEnabled) logger.info("close | ResultSet closed")
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
    }

}
