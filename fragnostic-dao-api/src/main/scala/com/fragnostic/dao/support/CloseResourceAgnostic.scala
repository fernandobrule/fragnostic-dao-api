package com.fragnostic.dao.support

import org.slf4j.{ Logger, LoggerFactory }

import java.sql._

/**
 * Created by Fernando Brule on 30-06-2015 22:23:00.
 * Generated by Tesseract.
 */
trait CloseResourceAgnostic {

  private[this] val logger: Logger = LoggerFactory.getLogger("CloseResourceAgnostic")

  def closeWithoutCommit(connection: Connection): Unit =
    try {
      connection.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.without.commit (${e.getMessage})")
    }

  def closeWithCommit(connection: Connection): Unit =
    try {
      connection.commit()
      connection.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.with.commit (${e.getMessage})")
    }

  def closeWithRollBack(connection: Connection): Unit =
    try {
      connection.rollback()
      connection.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.with.roollback (${e.getMessage})")
    }

  def close(statement: Statement): Unit =
    try {
      statement.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.statement (${e.getMessage})")
    }

  def close(prepStat: PreparedStatement): Unit =
    try {
      prepStat.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.prepared.statement (${e.getMessage})")
    }

  def close(resultSet: ResultSet): Unit =
    try {
      resultSet.close()
    } catch {
      case e: SQLException =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
      case e: Exception =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
      case e: Throwable =>
        logger.error(
          s"close.resource.agnostic.error.close.resultset (${e.getMessage})")
    }

  def close(resultSet: ResultSet, prepStat: PreparedStatement): Unit = {
    close(resultSet)
    close(prepStat)
  }

  def closeWithoutCommitAndReturnNone(connection: Connection): Option[Nothing] = {
    closeWithoutCommit(connection)
    None
  }

  def closeWithoutCommitAndReturnError(connection: Connection, error: String): String = {
    closeWithoutCommit(connection)
    error
  }

  def closeWithCommitAndReturnSomething[T](connection: Connection, someType: T): T = {
    closeWithCommit(connection)
    someType
  }

  def closeWithoutCommitAndReturnSomething[T](connection: Connection, someType: T): T = {
    closeWithoutCommit(connection)
    someType
  }

}
